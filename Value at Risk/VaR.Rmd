---
title: "Ryzyko rynkowe"
author: "Wiktoria Szczypka"
date: "7 kwietnia 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r}
library(fitdistrplus)
library(ggplot2)
library(dplyr)
library(tidyr)
library(lubridate)
library(gridExtra)

set.seed(1)
```



##Wstêp

W projekcie moim celem bêdzie zbadanie, która technika wyznaczania Value at Risk (VaR) jest najlepsza. Aby zrealizowaæ mój cel wybra³am 3 kursy walutowe z lat 2012-2018 - walutê kanadyjsk¹, czesk¹ oraz ukraiñsk¹. Bêdê porównywaæ 3 metody wyznaczania VaR:

* historyczn¹

* bootstrap 

* Monte Carlo

Oprócz VaR bêdê wyznaczaæ równie¿ Expected Shortfall (ES), pozwoli to zobaczyæ ile œrednio bêdzie wynosiæ strata je¿eli VaR zostanie przekroczony. Pozwoli to lepiej zobrazowaæ sytuacjê.

VaR bêdê wyznaczaæ stosuj¹c ruchome 500-elementowe okno estymacji, otrzymam wiêc 1263 wartoœci VaR oraz ES. Obie miary bêdê wyznaczaæ na poziomie 99%. 

Nastêpnie wykonam testy wsteczne dla ka¿dej metody i na ich podstawiê postaram siê przedstawiæ, któr¹ z wy¿ej wymienionych metod mo¿na uznaæ za najlepsz¹.


###Przedstawienie danych

Poni¿ej przedstawiê statystyki opisowe wybranych przeze mnie walut.

```{r}
data <- read.csv("C:/Users/Wiktoria/Documents/IiE/Rok 3/Semestr 6/ilosciowe aspekty/VaR/kursy.csv", sep=";")
data <- data[, c(1,6,13,15)]
data$data <- ymd(data$data)
summary(data[,2:4])
```

Na pierwszy rzut oka mo¿na zauwa¿yæ, ¿e najwiêksza ró¿nica w kursie jest w walucie kanadyjskiej - oko³o 0.8. Jednak po dok³adniejszym zapoznaniu siê widaæ, ¿e w walucie ukraiñskiej ró¿nica w kursie miêdzy minimum a maximum jest czterokrotna. Jest to zapewne spowodowane tym, ¿e Ukraina jest krajem niestabilnym gospodarczo. Kurs waluty czeskiej wydajê siê byæ stabilny.

Poni¿ej przedstawiê wykresy kursów, aby widaæ by³o jak siê zmienia³y w poszczególnych latach.


```{r}
data_gather <- gather(data[,1:4], key=waluta, value = kurs, -data)
ggplot(data=data_gather, aes(x=data, y=kurs, col=waluta)) + geom_line(lwd=1) + ggtitle("Kursy walut w latach 2012-2018")
```

Widaæ, ¿e waluta ukraiñska mia³a du¿y spadek, waluta czeska jest bardzo stabilna, a kanadyjska ma ro¿ne wahania - czasem spadek, czasem wzrost.

Za pomoc¹ poni¿szej funkcji obliczê teraz logarytmiczn¹ stopê zwrotu walut, a nastêpnie przedstawiê je na wykresie. Stopa zwrotu bêdzie w procentach z przeciwnym znakiem, aby straty wystêpowa³y w prawym ogonie rozk³adu.

```{r echo=TRUE}
return_rate <- function(vec){
  rate <- NA
  
  for (i in 2:length(vec)){
    rate[i] <-log(vec[i]/vec[i-1])
  }
  #prawy ogon - straty
  -rate*100
}
```

Przedstawiê poni¿ej na wykresach stopy zwrotu poszczególnych walut.

```{r}
data$rateCAD <- return_rate(data$X1CAD)
data$rateUAH <- return_rate(data$X1UAH)
data$rateCZK <- return_rate(data$X1CZK)
p1 <- ggplot(data=data, aes(x=data, y=rateCAD)) + geom_line(col='deeppink') + ggtitle("Stopy zwrotu CAD w latach 2012-2018")
p2 <- ggplot(data=data, aes(x=data, y=rateUAH)) + geom_line(col='deeppink') + ggtitle("Stopy zwrotu UAH w latach 2012-2018")
p3 <- ggplot(data=data, aes(x=data, y=rateCZK)) + geom_line(col='deeppink') + ggtitle("Stopy zwrotu CZK w latach 2012-2018")
grid.arrange(p1, p2, p3, nrow=3)
```

Widaæ od razu, ¿e w walucie ukraiñskiej stopy zwrotu dochodz¹ a¿ do 50%, mo¿e to œwiadczyæ o du¿ym ryzyku je¿eli inwestuje siê w t¹ walutê. Pozosta³e stopy s¹ stabilniejsze.


##Metody obliczania VaR

W tej czêœci projektu zajmê siê przedstawieniem 3 technik wyznaczania VaR i uzyskanych wyników.

###Metoda historyczna

Metoda ta opiera siê na bezpoœrednim wykorzystaniu danych historycznych. Na podstawie tych danych w ka¿dym okienku 500 obserwacji tworzy siê rozk³ad empiryczny stóp zwrotu za pomoc¹ którego jest siê w stanie wyznaczyæ kwantyl na danym poziomie istotnoœci. Za pomoc¹ kwantyla jest siê w stanie ju¿ obliczyæ VaR oraz ES.

Poni¿ej przedstawiam funkcjê, która realizuje powy¿ej przedstawiony algorytm.

```{r echo=TRUE}
hist_method <- function(vec_rate, days = 500, level=.99){
  
  VaR <- NA
  ES <- NA
  
  for (i in 2:(length(vec_rate)-500)){
    temp_vec <- vec_rate[i:(days+i-1)]
    VaR[i] <- quantile(temp_vec, level, na.rm = TRUE)
    ES[i] <- mean(temp_vec[temp_vec >= VaR[i]])
  }
  return(list(VaR=VaR, ES=ES))
}
```

Przedstawiê teraz wykresy, które obrazuj¹ VaR i ES dla ka¿dej waluty.

```{r}
hist_CAD <- hist_method(data$rateCAD)
hist_UAH <- hist_method(data$rateUAH)
hist_CZK <- hist_method(data$rateCZK)

CAD1 <- data.frame(data = data$data[502:1764], rate = data$rateCAD[502:1764], VaR = hist_CAD$VaR[-1], ES = hist_CAD$ES[-1])
CAD1 <- gather(CAD1, key = name, value = value, -data)
ggplot(data=CAD1, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda historyczna CAD")
```

VaR przez wszystkie lata wynosi oko³o 1,5%. Oznacza to, ¿e na 99% inwestuj¹c w walutê nie stracimy wiêcej ni¿ 1,5%. Je¿eli jednak strata przekroczy 1,5% to szacowana wartoœæ tej straty bêdzie wynosiæ 2%.

```{r}
UAH1 <- data.frame(data = data$data[502:1764], rate = data$rateUAH[502:1764], VaR = hist_UAH$VaR[-1], ES = hist_UAH$ES[-1])
UAH1 <- gather(UAH1, key = name, value = value, -data)
ggplot(data=UAH1, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda historyczna UAH")
```

Ze wzglêdu na du¿y spadek kursu waluty ukraiñskiej widaæ, ze w latach 2015-2017 VaR wynosi³ nawet 12,5%, a ES przyjmowa³ wartoœci w pobli¿u 25%. 

```{r}
CZK1 <- data.frame(data = data$data[502:1764], rate = data$rateCZK[502:1764], VaR = hist_CZK$VaR[-1], ES = hist_CZK$ES[-1])
CZK1 <- gather(CZK1, key = name, value = value, -data)
ggplot(data=CZK1, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda historyczna CZK")
```

Zarówno VaR jak i ES na przestrzeni lat mala³o. Pod koniec 2018 roku wartoœæ VaR wynosi³a 0,5%, wiêc na 99% strata nie wyniesie wiêcej ni¿ 0,5%. Jest to wynik potwierdzaj¹cy stabilnoœæ tej waluty.


###Metoda bootstrap

Wykorzystuje siê w tej metodzie metodê historyczn¹, lecz tworzê alternatywne historie. W ka¿dym oknie 500 obserwacji losujê dan¹ liczbê obserwacji ze zwracaniem, a nastêpnie dla nich obliczam VaR metod¹ historyczn¹. Algorytm ten powtarzam N razy. Koñcowa wartoœæ VaR dla danego okna to œrednia z uzyskanych wartoœci. Oszacowania te mog¹ byæ dok³adniejsze ni¿ w metodzie historycznej.

Poni¿ej przedstawiam funkcjê, która realizuje powy¿ej przedstawiony algorytm.

```{r echo=TRUE}
boot_method <- function(vec_rate, days = 500, level = .99, N = 500){
  
  VaR <- NA
  ES <- NA
  
  for (i in 2:(length(vec_rate)-500)){
    
    temp_vec <- vec_rate[i:(days+i-1)]
    temp_var <- NULL
    temp_es <- NULL
    
    for (j in 1:N){
      temp <- sample(temp_vec,700, replace = T)
      temp_var[j] <- quantile(temp, level, na.rm = TRUE)
      temp_es[j] <- mean(temp[temp >= temp_var[j]])
    }
    
    VaR[i] <- mean(temp_var)
    ES[i] <- mean(temp_es)
  }
  
  return(list(VaR=VaR, ES=ES))
}
```

Przedstawiê teraz wykresy, które obrazuj¹ VaR i ES dla ka¿dej waluty.

```{r}
boot_CAD <- boot_method(data$rateCAD)
boot_UAH <- boot_method(data$rateUAH)
boot_CZK <- boot_method(data$rateCZK)

CAD2 <- data.frame(data = data$data[502:1764], rate = data$rateCAD[502:1764], VaR = boot_CAD$VaR[-1], ES = boot_CAD$ES[-1])
CAD2 <- gather(CAD2, key = name, value = value, -data)
ggplot(data=CAD2, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda bootstrap CAD")
```


```{r}
UAH2 <- data.frame(data = data$data[502:1764], rate = data$rateUAH[502:1764], VaR = boot_UAH$VaR[-1], ES = boot_UAH$ES[-1])
UAH2 <- gather(UAH2, key = name, value = value, -data)
ggplot(data=UAH2, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda bootstrap UAH")
```



```{r}
CZK2 <- data.frame(data = data$data[502:1764], rate = data$rateCZK[502:1764], VaR = boot_CZK$VaR[-1], ES = boot_CZK$ES[-1])
CZK2 <- gather(CZK2, key = name, value = value, -data)
ggplot(data=CZK2, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda bootstrap CZK")
```

Widaæ, ¿e wartoœci VaR i ES nie zmieniaj¹ siê teraz tak skokowo jak w metodzie historycznej, lecz wystêpuj¹ 'drgania'. Wartoœci te s¹ jednak bardzo podobne jak w poprzedniej metodzie.


###Metoda Monte Carlo

Metoda ta polega na tym, aby wybraæ rozk³ad teoretyczny, który jak najbardziej bêdzie podobny do rozk³adu empirycznego, które tworzy 500 obserwacji w danym okienku. Nastêpnie z wybranego wczeœniej rozk³adu teoretycznego losuje ze zwracaniem dan¹ liczbê obserwacji i na ich podstawiê wyznaczam VaR tak samo jak w poprzednich metodach. Algorytm ten dla danego okna powtarzam N razy, a koñcowy VaR obliczam jako ich œredni¹.

W swoim algorytmie bêdê bra³a pod uwagê 3 rozk³ady - t-Studenta, logistyczny i normalny. Za pomoc¹ funkcji `fitdistr` do ka¿dego rozk³adu dopasuje parametry, które najbardziej bêd¹ pasowaæ. Uzyskam wiêc dla ka¿dej waluty 3 ró¿ne ci¹gi wartoœci VaR oraz ES w zale¿noœci od rozk³adu. W dalszej czêœci projektu, za pomoc¹ testów wstecznych, przedstawiê za pomoc¹ którego rozk³adu uzyskano najlepsze wyniki.

Poni¿ej przedstawiam funkcjê, która realizuje powy¿ej przedstawiony algorytm.

```{r echo=TRUE}
monte_method2 <- function(vec_rate, days = 500, level = .99, N = 50){
  
  VaR <- data.frame(NA, NA, NA)
  colnames(VaR) <- c("t", "logis", "norm")
  ES <- data.frame(NA, NA, NA)
  colnames(ES) <- c("t", "logis", "norm")
  
  for (i in 2:(length(vec_rate)-500)){
    
    temp_vec <- vec_rate[i:(days+i-1)]
    temp_var <- data.frame(0,0,0)
    temp_es <- data.frame(0,0,0)
    colnames(temp_var) <- c("t", "logis", "norm")
    colnames(temp_es) <- c("t", "logis", "norm")
    
    for(j in 1:N){
      
      temp_t <- rt(700, fitdistr(temp_vec, "t")$estimate[3])
      temp_var[j,1] <- quantile(temp_t, level, na.rm = TRUE)
      temp_es[j,1] <- mean(temp_t[temp_t >= temp_var[j,1]])
      
      temp_l <- rlogis(700, fitdistr(temp_vec, "logistic")$estimate)
      temp_var[j,2] <- quantile(temp_l, level, na.rm = TRUE)
      temp_es[j,2] <- mean(temp_l[temp_l >= temp_var[j,2]])
      
      
      temp_n <- rnorm(700, fitdistr(temp_vec, "normal")$estimate)
      temp_var[j,3] <- quantile(temp_n, level, na.rm = TRUE)
      temp_es[j,3] <- mean(temp_n[temp_n >= temp_var[j,3]])
    }
    
    for(k in 1:3){
      VaR[i,k] <- mean(temp_var[,k])
      ES[i,k] <- mean(temp_es[,k])
    }
    
  }
  return(list(VaR=VaR, ES=ES))
}
```

Poni¿ej przedstawiê otrzymane wyniki.

```{r}
monte_CAD <- monte_method2(data$rateCAD)
monte_UAH <- monte_method2(data$rateUAH)
monte_CZK <- monte_method2(data$rateCZK)
```



```{r}
CAD3 <- data.frame(data = data$data[501:1764], rate = data$rateCAD[501:1764], monte_CAD)

CAD3_t <- gather(CAD3[,c(1,2,3,6)], key = name, value=value, -data )
p1 <- ggplot(data=CAD3_t, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda Monte Carlo - rozk³ad t-Studenta - CAD")

CAD3_l <- gather(CAD3[,c(1,2,4,7)], key = name, value=value, -data )
p2 <- ggplot(data=CAD3_l, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda Monte Carlo - rozk³ad logistyczny - CAD")

CAD3_n <- gather(CAD3[,c(1,2,5,8)], key = name, value=value, -data )
p3 <- ggplot(data=CAD3_n, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda Monte Carlo - rozk³ad normalny - CAD")

grid.arrange(p1,p2,p3,nrow=3)
```

Mo¿na zauwa¿yæ, ¿e wartoœæ VaR i ES jest bardzo przeszacowana. Potwierdz¹ to testy wsteczne, ale na pierwszy rzut oka wygl¹da, ¿e metoda Monte Carlo jest bardzo s³aba.

Poni¿ej przedstawiam wartoœci VaR dla ka¿dego rozk³adu na jednym wykresie.

```{r}
CAD3_all <- gather(CAD3[,c(1,2,3,4,5)], key = name, value=value, -data )
ggplot(data=CAD3_all, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda Monte Carlo - CAD")
```

Mo¿na zauwa¿yæ, ¿e wartoœci VaR oszacowane przez rozk³ad logistyczny s¹ zawy¿one bardziej ni¿ przez pozosta³e dwa rozk³ady.

Poni¿ej wykresy dla waluty ukraiñskiej.

```{r}
UAH3 <- data.frame(data = data$data[501:1764], rate = data$rateUAH[501:1764], monte_UAH)

UAH3_t <- gather(UAH3[,c(1,2,3,6)], key = name, value=value, -data )
ggplot(data=UAH3_t, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda Monte Carlo - rozk³ad t-Studenta - UAH")

UAH3_l <- gather(UAH3[,c(1,2,4,7)], key = name, value=value, -data )
ggplot(data=UAH3_l, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda Monte Carlo - rozk³ad logistyczny - UAH")

UAH3_n <- gather(UAH3[,c(1,2,5,8)], key = name, value=value, -data )
ggplot(data=UAH3_n, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda Monte Carlo - rozk³ad normalny - UAH")

```

Widaæ, ¿e w przypadku waluty ukraiñskiej wartoœci nie s¹ przeszacowane. Wyniki uzyskane za pomoc¹ rozk³adu logistycznego i normalnego mo¿na uznaæ za podobne. Jednak w rozk³adzie t-Studenta wartoœæ ES w pewnym punkcie by³a o wiele wiêksza ni¿ w pozosta³ych.

Poni¿ej porównanie uzyskanych wyników na jednym wykresie.

```{r}
UAH3_all <- gather(UAH3[,c(1,2,3,4,5)], key = name, value=value, -data )
ggplot(data=UAH3_all, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda Monte Carlo - UAH")
```

Mo¿na zauwa¿yæ, ¿e wartoœæ VaR obliczona za pomoc¹ t-Studenta jest bardzo du¿a w porównaniu do dwóch pozosta³ych.

```{r}
CZK3 <- data.frame(data = data$data[501:1764], rate = data$rateCZK[501:1764], monte_CZK)

CZK3_t <- gather(CZK3[,c(1,2,3,6)], key = name, value=value, -data )
p1 <- ggplot(data=CZK3_t, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda Monte Carlo - rozk³ad t-Studenta - CZK")

CZK3_l <- gather(CZK3[,c(1,2,4,7)], key = name, value=value, -data ) 
p2 <- ggplot(data=CZK3_l, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda Monte Carlo - rozk³ad logistyczny - CZK")

CZK3_n <- gather(CZK3[,c(1,2,5,8)], key = name, value=value, -data )
p3 <- ggplot(data=CZK3_n, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda Monte Carlo - rozk³ad normalny - CZK")

grid.arrange(p1,p2,p3,nrow=3)
```

Mo¿na zauwa¿yæ, ¿e wartoœci podobnie jak w przypadku waluty kanadyjskiej s¹ bardzo przeszacowane. Wystêpuj¹ ró¿nice miêdzy wartoœciami pochodz¹cych z ró¿nych rozk³adów. Jednak w ka¿dym przypadku ani razu wartoœæ stopy zwrotu nie przekracza wartoœci VaR.

Poni¿ej porównanie wyników dla trzech rozk³adów.

```{r}
CZK3_all <- gather(CZK3[,c(1,2,3,4,5)], key = name, value=value, -data )
ggplot(data=CZK3_all, aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Metoda Monte Carlo - CZK")
```

Widaæ ró¿nice w wynikach jednak wygl¹da na to, ¿e nie s¹ one przydatne - s¹ bardzo zawy¿one.

###Podsumowanie metod

Poni¿ej wykresy przedstawiaj¹ce wszystkie metody dla ka¿dej waluty.

```{r}
CAD_all <- data.frame(data = data$data[502:1764], rate = data$rateCAD[502:1764], VaR.boot = boot_CAD$VaR[-1], VaR.hist = hist_CAD$VaR[-1], VaR.logis = monte_CAD$VaR$logis[-1], VaR.norm = monte_CAD$VaR$norm[-1], VaR.t = monte_CAD$VaR$t[-1])
CAD_all <- gather(CAD_all, key=name, value = value, -data)
ggplot(data=CAD_all,aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Porównanie metod - CAD")
```

Widaæ, ¿e wyniki metody historycznej i bootstrap s¹ do siebie podobne. Mo¿na spodziewaæ siê, ¿e to one oka¿¹ siê najlepsze, poniewa¿ wyniki uzyskane z metody Monte Carlo s¹ bardzo przeszacowane.

```{r}
UAH_all <- data.frame(data = data$data[502:1764], rate = data$rateUAH[502:1764], VaR.boot = boot_UAH$VaR[-1], VaR.hist = hist_UAH$VaR[-1], VaR.logis = monte_UAH$VaR$logis[-1], VaR.norm = monte_UAH$VaR$norm[-1], VaR.t = monte_UAH$VaR$t[-1])
UAH_all <- gather(UAH_all, key=name, value = value, -data)
ggplot(data=UAH_all,aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Porównanie metod - UAH")
```

Ponownie mo¿na zauwa¿yæ, ¿e wyniki z metody historycznej i bootstrap s¹ podobne, tak samo jak z Monte Carlo za pomoc¹ rozk³adu logistycznego i normalnego. Ciê¿ko okreœliæ, która z metod oka¿e siê najlepsza. Wydajê mi siê, ¿e nie bêdzie to ta uzyskana z rozk³adu t-Studenta, która wydaje siê byæ przeszacowana.


```{r}
CZK_all <- data.frame(data = data$data[502:1764], rate = data$rateCZK[502:1764], VaR.boot = boot_CZK$VaR[-1], VaR.hist = hist_CZK$VaR[-1], VaR.logis = monte_CZK$VaR$logis[-1], VaR.norm = monte_CZK$VaR$norm[-1], VaR.t = monte_CZK$VaR$t[-1])
CZK_all <- gather(CZK_all, key=name, value = value, -data)
ggplot(data=CZK_all,aes(x=data, y=value, col=name)) + geom_line() + ggtitle("Porównanie metod - CZK")
```

Tutaj podobnie jak w przypadku waluty kanadyjskiej: metoda Monte Carlo bardzo przeszacowana, a pozosta³e wyniki s¹ bardzo podobne.


##Testy wsteczne

W celu zbadania, która z metod da³a najdok³adniejsze wyniki wartoœci VaR wykonam testy wsteczne. Za ich pomoc¹ postaram siê odpowiedzieæ, która metoda okaza³a siê byæ najlepsz¹.

###Test wartoœci rzeczywistej

Pierwszym testem, który wykonam jest test wartoœci rzeczywistej. Porównuje on wartoœæ VaR obliczon¹ na dany dzieñ ze stop¹ zwrotu. Bior¹c pod uwagê, ¿e w projekcie wyznaczam 99% VaR to im wynik (stosunek sytuacji, gdy VaR jest wiêkszy od stopy zwrotu do wszystkich obserwacji) jest bardziej zbli¿ony do 0.99  tym lepiej. Gdy wartoœæ testu jest równa 1 nie jest dobrze - oznacza to, ¿e wartoœci s¹ zawy¿one i niepotrzebnie bêdziemy magazynowaæ kapita³.

Poni¿ej funkcja, która pozwala obliczyæ wynik testu.

```{r echo=TRUE}
test_real_value <- function(rate, VaR){
  
  acc = 0
  
  for (i in 1:length(rate)){
    if(VaR[i] > rate[i]){
      acc = acc+1
    }
  }
  return (round(acc/length(rate),3))
}
```

Teraz przedstawiê tabelê z wynikami testu dla ka¿dej metody.

```{r}
real_value <- data.frame(0,0,0)


real_value_CAD <- c(test_real_value(data$rateCAD[502:1764],hist_CAD$VaR[-1]),
                    test_real_value(data$rateCAD[502:1764],boot_CAD$VaR[-1]),
                    test_real_value(data$rateCAD[502:1764],monte_CAD$VaR$logis[-1]),
                    test_real_value(data$rateCAD[502:1764],monte_CAD$VaR$norm[-1]),
                    test_real_value(data$rateCAD[502:1764],monte_CAD$VaR$t[-1]))

real_value_UAH <- c(test_real_value(data$rateUAH[502:1764],hist_UAH$VaR[-1]),
                 test_real_value(data$rateUAH[502:1764],boot_UAH$VaR[-1]),
                 test_real_value(data$rateUAH[502:1764],monte_UAH$VaR$logis[-1]),
                 test_real_value(data$rateUAH[502:1764],monte_UAH$VaR$norm[-1]),
                 test_real_value(data$rateUAH[502:1764],monte_UAH$VaR$t[-1])) 


real_value_CZK <- c(test_real_value(data$rateCZK[502:1764],hist_CZK$VaR[-1]),
                    test_real_value(data$rateCZK[502:1764],boot_CZK$VaR[-1]),
                    test_real_value(data$rateCZK[502:1764],monte_CZK$VaR$logis[-1]),
                    test_real_value(data$rateCZK[502:1764],monte_CZK$VaR$norm[-1]),
                    test_real_value(data$rateCZK[502:1764],monte_CZK$VaR$t[-1])) 

real_value <- data.frame(real_value_CAD,real_value_UAH,real_value_CZK)
colnames(real_value) <- c("CAD", "UAH", "CZK")
rownames(real_value) <- c("hist", "boot", "log", "normal","t")
real_value
```

Test potwierdzi³ wczeœniejsze przypuszczenia - metoda Monte Carlo w wiêkszoœci przypadków zawy¿a³a wartoœæ VaR. Dobre wyniki mia³a jedynie w przypadku waluty ukraiñskiej. Wyniki metody historycznej i bootstrap s¹ do siebie bardzo podobnie. Jedynie w przypadku waluty kanadyjskiej trochê lepiej wypad³a metoda historyczna.


###Test Kupca

Jest to test statystyczny, który sprawdza czy VaR jest dobrze wyznaczony. U¿ywaj¹c okien zwrotu, z których wczeœniej wylicza³am VaR, badam, ile razy stopa zwrotu jest wiêksza od wartoœci VaR (wyj¹tków). Dla okna o d³ugoœci 500 i poziomu istotnoœci 0.01 przyjmuje siê, ¿e wyestymowany VaR jest prawid³owy gdy wystêpuje od 1 do 10 takich wyj¹tków. Ca³y algorytm powtarzam dla ka¿dego okienka. Tym sposobem dostajê wynik od 0 do 1 - im wiêkszy tym lepiej wyznaczony zosta³ VaR.

Testu Kupca nie ma jednak sensu wykonywaæ dla metody historycznej i bootstrap, gdy¿ wynik bêdzie równy 1 ze wzglêdu wykorzystanie w tych metodach kwantylu bezpoœrednio wyznaczonego z rozk³adu empirycznego obserwacji znajduj¹cych sie w danym okienku.

Poni¿ej funkcja, która przedstawia test Kupca.

```{r echo=TRUE}
test_kupca <- function(rate, VaR, days = 500){
  
  value <- NULL
  stat <- NULL
  
  for (i in (1:length(var)))
  {
    temp_vec <- rate[i:(days+i-1)]
    
    #wyjatek 1
    excep <- ifelse(temp_vec > VaR[i], 1 , 0)
    stat[i] <- sum(excep)
    
    #przedzial odpowiedni - 1-10
    if (stat[i] <= 10 && stat[i] >= 1){
      value[i] <- 1
    }else {
      value[i] <- 0}
  }
  
  acc <- sum(value)/length(VaR)
  return(round(acc,3))
}
```

Poni¿ej przedstawiam wyniki testu dla metody Monte Carlo.

```{r}
kupc_CAD <- c(test_kupca(data$rateCAD[-1],monte_CAD$VaR$logis[-1]),
test_kupca(data$rateCAD[-1],monte_CAD$VaR$t[-1]),
test_kupca(data$rateCAD[-1],monte_CAD$VaR$norm[-1]))

kupc_UAH <- c(test_kupca(data$rateUAH[-1],monte_UAH$VaR$logis[-1]),
test_kupca(data$rateUAH[-1],monte_UAH$VaR$t[-1]),
test_kupca(data$rateUAH[-1],monte_UAH$VaR$norm[-1]))


kupc_CZK <- c(test_kupca(data$rateCZK[-1],monte_CZK$VaR$logis[-1]),
test_kupca(data$rateCZK[-1],monte_CZK$VaR$t[-1]),
test_kupca(data$rateCZK[-1],monte_CZK$VaR$norm[-1]))

kupc_value <- data.frame(kupc_CAD,kupc_UAH,kupc_CZK)
colnames(kupc_value) <- c("CAD", "UAH", "CZK")
rownames(kupc_value) <- c("log", "t","normal")
kupc_value
```

Widaæ, ¿e test ten pokazuje, ¿e metoda ta nie nadaje siê. Bardzo rzadko wartoœæ stopy zwrotu przekracza³a wartoœæ VaR. Jak pisa³am wczeœniej to wcale nie jest dobry wynik, gdy¿ wartoœci te s¹ zawy¿one. 

###Test Christoffersena

Test ten sprawdza czy przekroczenia VaR s¹ niezale¿ne w czasie. Test ten wykonam za pomoc¹ statystyki na poziomie istotnoœci 0.01. Statystyka ta ma w przybli¿eniu rozk³ad chi-kwadrat o 1 stopniu swobody, wiêc hipotezê zerow¹ (przekroczenia VaR s¹ niezale¿ne w czasie) bêdê odrzucaæ, gdy wartoœæ statystyki bêdzie wiêksza b¹dŸ równa 6.635 (tyle wynosi kwantyl 0.99 rozk³adu). Algorytm ten bêdê powtarzaæ dla ka¿dego okienka, gdy test odrzuci hipotezê zerow¹ bêdê przypisywaæ 0, a gdy nie odrzuci - 1. Koñcowo dostanê wynik w przedziale od 0 do 1 - im wiêkszy tym lepszy.

Nie ma sensu wykonywaæ go dla metody Monte Carlo, gdy¿ ju¿ we wczeœniejszych testach metoda okaza³a siê byæ nieskuteczna. Test ten wykonam dla metody bootstrap i historycznej.

Poni¿ej przedstawiam funkcjê, która umo¿liwia mi wykonanie testu.

```{r echo=TRUE}
test_christoffersen <- function(rate, VaR, days=500){
  
  stat <- NULL
  value <- NULL
  
  for (i in 1:length(VaR)) {
    
    
    temp_vec <- rate[i:(days+i-1)]
    #wyjatek 1 
    excep <- ifelse(temp_vec>VaR[i],1,0)
    
    u00 <- 0
    u01 <- 0
    u10 <- 0
    u11 <- 0
    
    for(j in 1:(length(excep)-1)){
      if(excep[j] == 0 && excep[j+1]==0){
        u00 = u00+1
      } else if(excep[j] == 0 && excep[j+1]==1){
        u01 = u01+1
      } else if(excep[j] == 1 && excep[j+1]==0){
        u10 = u10+1
      } else {
        u11 = u11+1
      }
    }
    
    p <- (u00+u10)/(u00+u01+u10+u11)
    p0 <- u00/(u00+u01)
    p1 <- u10/(u10+u11)
    
    stat[i] <- -2*log((p/p0)^u00*((1-p)/(1-p0))^u01*(p/p1)^u10*((1-p)/(1-p1))^u11)
    
    #alfa 0.01
    if(stat[i]>=6.635){
      value[i] = 0
    } else {
      value[i] = 1
    }
    
  }
  
  acc <- sum(value)/length(VaR)
  return(round(acc,3))
  
}
```

Poni¿ej przedstawiam wyniki testu.

```{r}
chris_CAD <- c(test_christoffersen(data$rateCAD[-1],hist_CAD$VaR[-1]),
               test_christoffersen(data$rateCAD[-1],boot_CAD$VaR[-1]))

chris_UAH <- c(test_christoffersen(data$rateUAH[-1],hist_UAH$VaR[-1]),
               test_christoffersen(data$rateUAH[-1],boot_UAH$VaR[-1]))

chris_CZK <- c(test_christoffersen(data$rateCZK[-1],hist_CZK$VaR[-1]),
               test_christoffersen(data$rateCZK[-1],boot_CZK$VaR[-1]))


chris_value <- data.frame(chris_CAD,chris_UAH,chris_CZK)
colnames(chris_value) <- c("CAD", "UAH", "CZK")
rownames(chris_value) <- c("hist", "boot")
chris_value
```

Jak widaæ wartoœci te wynosz¹ albo 1 albo s¹ bardzo blisko 1. Znaczy to, ¿e zdarzenia VaR s¹ niezale¿ne w czasie, a obie metody s¹ bardzo dobre.

##Podsumowanie

* Metoda Monte Carlo okaza³a siê byæ najgorsz¹. Jest to spowodowane faktem, ¿e wybrane rozk³ady Ÿle oddaj¹ rozk³ad stop zwrotu co powoduje b³êdne oszacowanie wartoœci VaR dla prawdziwego ¿ycia.

* Ciê¿ko wybraæ, która metoda jest lepsza - historyczna czy bootstrap. Daj¹ one bardzo podobne wyniki. Spodziewa³am siê jednak, ¿e ze wzglêdu na wiêksz¹ z³o¿onoœæ metody bootstrap oka¿e siê ona dok³adniejsza. Jej z³o¿onoœæ obliczeniowa jest du¿o wiêksza ni¿ dla metody historycznej. Pojawia siê wiêc pytanie czy dla tego problemu jest sens jej wykonywanie skoro wcale nie uzyskuje siê lepszego wyniku ni¿ dla metody historycznej. 

* Podsumowuj¹c, uwa¿am, ¿e najlepsza dla problemu omawianego w tym projekcie okaza³a siê byæ metoda historyczna, której wykonanie zajmuje bardzo niewiele czasu. 

